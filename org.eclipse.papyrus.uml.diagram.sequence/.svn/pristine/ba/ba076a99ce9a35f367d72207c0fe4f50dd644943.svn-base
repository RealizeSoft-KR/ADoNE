/*****************************************************************************
 * Copyright (c) 2024 RealizeSoft and others.
 *
 * All rights reserved. This file is part of a software program that is made
 * available under the terms of the Eclipse Public License 2.0 which
 * accompanies this distribution and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *   RealizeSoft - Original development and implementation.
 *****************************************************************************/
package org.eclipse.papyrus.uml.diagram.sequence.referencialgrilling;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.emf.common.command.AbstractCommand;
import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.gef.EditPart;
import org.eclipse.gef.EditPartViewer;
import org.eclipse.gef.GraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
import org.eclipse.gmf.runtime.notation.Bounds;
import org.eclipse.gmf.runtime.notation.Diagram;
import org.eclipse.gmf.runtime.notation.Node;
import org.eclipse.gmf.runtime.notation.View;
import org.eclipse.papyrus.uml.diagram.sequence.edit.parts.AbstractMessageEditPart;
import org.eclipse.papyrus.uml.diagram.sequence.edit.parts.AdoneCombinedFragmentEditPart;
import org.eclipse.papyrus.uml.diagram.sequence.edit.parts.AdoneMessageSyncEditPart;
import org.eclipse.papyrus.uml.diagram.sequence.edit.parts.BehaviorExecutionSpecificationEditPart;
import org.eclipse.papyrus.uml.diagram.sequence.edit.parts.CombinedFragmentEditPart;
import org.eclipse.papyrus.uml.diagram.sequence.edit.parts.InteractionOperandEditPart;
import org.eclipse.papyrus.uml.diagram.sequence.edit.parts.InteractionOperandGuardEditPart;
import org.eclipse.papyrus.uml.diagram.sequence.edit.parts.LifelineEditPart;
import org.eclipse.papyrus.uml.diagram.sequence.util.AdoneDiagramUtil;
import org.eclipse.papyrus.uml.diagram.sequence.util.AdoneSequenceUtil;
import org.eclipse.papyrus.uml.diagram.sequence.util.SelfMessageHelper;
import org.eclipse.swt.widgets.Display;
import org.eclipse.uml2.uml.BehaviorExecutionSpecification;
import org.eclipse.uml2.uml.CombinedFragment;
import org.eclipse.uml2.uml.ExecutionOccurrenceSpecification;
import org.eclipse.uml2.uml.Interaction;
import org.eclipse.uml2.uml.InteractionFragment;
import org.eclipse.uml2.uml.InteractionOperand;
import org.eclipse.uml2.uml.Lifeline;
import org.eclipse.uml2.uml.Message;
import org.eclipse.uml2.uml.MessageOccurrenceSpecification;
import org.eclipse.uml2.uml.Namespace;
import org.eclipse.uml2.uml.OccurrenceSpecification;
import org.eclipse.uml2.uml.UMLFactory;

/**
 * A policy class that synchronizes the graphical view with the UML model in a deferred manner
 * It handles activation and deactivation of components, ensuring graphical updates are deferred and executed
 * asynchronously to maintain consistency between the model and its representation. This class also
 * includes mechanisms for updating and correcting model elements based on graphical edits, such as
 * synchronizing interaction fragments order by graphical information , reordering lifelines, updating
 * execution specifications, and managing the Z-order of graphical elements.
 */
public class AdoneDeferredModelViewSyncEditPolicy extends GridManagementEditPolicy {

	private Interaction intac;

	private Diagram currentDiagram;

	// Copy of the current Interaction for backup.
	private Interaction copyInteraction;

	// Copy of the current Diagram for backup.
	private Diagram copyDiagram;

	// Scheduler for delayed or periodic tasks execution.
	private ScheduledExecutorService scheduler;


	/**
	 * Activates the current component, initializing its resources and settings. This method extends
	 * the standard activation process by setting up a single-threaded scheduler. The scheduler is
	 * used for executing delayed or periodic tasks in a controlled manner, ensuring that these tasks
	 * are managed by a dedicated thread. This setup is particularly useful for handling asynchronous
	 * operations that need to be performed after the component becomes active, such as updating
	 * graphical representations or processing background tasks without blocking the UI thread.
	 */
	@Override
	public void activate() {
		super.activate(); // Call the superclass method to handle standard activation procedures
		// Initialize the scheduler with a single thread to manage delayed tasks
		scheduler = Executors.newSingleThreadScheduledExecutor();
	}


	/**
	 * Consolidates updates to the sequence diagram's model after graphical edits have been made. This method ensures
	 * the consistency between the graphical representation and the underlying UML model by performing a series of
	 * updates. These updates include correcting execution occurrence specifications for self-calls, updating the
	 * order and positions of lifelines and fragments based on their graphical edits, correcting the placement of
	 * dangling behavior executions, and adjusting the Z-order of graphical elements to maintain logical layering.
	 * This comprehensive update is crucial for maintaining the accuracy and integrity of both the visual and
	 * semantic aspects of the sequence diagram after any modification.
	 */
	@Override
	public void updateCoveredAndOwnerAfterUpdate() {
		this.getInteraction();
		this.deleteExecutionOcSpecForSelfCall();
		this.updateLifelineByGraphicalEditParts();
		this.updateFragmentsByGraphicalEditParts();
		this.updateMainLogicBesFinishFragment();
		this.deleteDangglingBes();
		this.createBesForDangglingView();
		this.updateBehaviorExeSpecLocation();
		this.updateZOrderByGraphicalEditParts();
	}

	/**
	 * Updates the order of lifelines in the UML Interaction object based on their graphical positions
	 * within the Sequence Diagram. This method is crucial in the "Change Element Order Mode" where the
	 * user has rearranged the lifelines horizontally. It collects all LifelineEditParts, sorts them by
	 * their X coordinates to reflect the new order, and then applies this order to the lifelines in the
	 * UML model, ensuring the model accurately represents the diagram's current state.
	 */
	private void updateLifelineByGraphicalEditParts() {
		// List to hold the lifeline edit parts for sorting
		List<LifelineEditPart> lifelineEditParts = new ArrayList<>();

		// Iterate through all edit parts to find and add lifeline edit parts to the list
		for (GraphicalEditPart ep : AdoneSequenceUtil.getAllEditParts(getHost())) {
			if (ep instanceof LifelineEditPart) {
				lifelineEditParts.add((LifelineEditPart) ep);
			}
		}

		// Sort the lifeline edit parts by their X coordinates
		Collections.sort(lifelineEditParts, new Comparator<GraphicalEditPart>() {
			@Override
			public int compare(GraphicalEditPart ep1, GraphicalEditPart ep2) {
				int x1 = AdoneSequenceUtil.getAbsoluteBoundsForMessageEp(ep1).x;
				int x2 = AdoneSequenceUtil.getAbsoluteBoundsForMessageEp(ep2).x;
				return Integer.compare(x1, x2);
			}
		});

		// Retrieve the current list of UML lifelines
		List<Lifeline> umlLifelines = this.intac.getLifelines();

		// Create a new list for the sorted UML lifelines based on the graphical order
		List<Lifeline> sortedUmlLifelines = new ArrayList<>();
		for (LifelineEditPart lep : lifelineEditParts) {
			Lifeline lifelineModel = (Lifeline) lep.resolveSemanticElement();
			sortedUmlLifelines.add(lifelineModel);
		}

		// Execute a command to update the UML model with the new lifeline order
		execute(new AbstractCommand("ReOrder Lifelines In Interaction") {

			@Override
			public void execute() {

				// Update the UML model's lifeline list with the new order
				umlLifelines.clear();
				umlLifelines.addAll(sortedUmlLifelines);

			}

			@Override
			public void redo() {
				// Redo functionality can be implemented if necessary
			}


		});
	}

	/**
	 * Creates BehaviorExecutionSpecifications (BES) for dangling views in a Sequence Diagram, where
	 * certain graphical representations lack corresponding semantic elements in the model. This
	 * command scans the diagram for BehaviorExecutionSpecificationEditParts without associated
	 * semantic elements and attempts to create and link new BES instances to these orphaned views.
	 * It ensures that every graphical representation of a behavior execution in the diagram is
	 * backed by a proper element in the UML model, thereby improving the diagram's consistency
	 * and correctness.
	 */
	private void createBesForDangglingView() {

		execute(new AbstractCommand("Create BehaviorExecutionSpec For Dangling View") {

			@Override
			public void execute() {

				EditPartViewer viewer = getHost().getRoot().getViewer();
				Map<?, ?> editPartRegistry = viewer.getEditPartRegistry();

				List<GraphicalEditPart> relevantEditParts = new ArrayList<>();

				boolean targetBesFound = false;

				// Collect all BES and Message EditParts, identify if there are any dangling BES
				for (Object value : editPartRegistry.values()) {

					if (value instanceof BehaviorExecutionSpecificationEditPart) {

						BehaviorExecutionSpecificationEditPart besEp = (BehaviorExecutionSpecificationEditPart) value;

						// Check for BES without associated semantic elements or container (2024-01-28)
						if (besEp.resolveSemanticElement() == null || besEp.resolveSemanticElement().eContainer() == null) {
							targetBesFound = true;
						}

						relevantEditParts.add((GraphicalEditPart) value);
					}

					if (value instanceof AbstractMessageEditPart) {
						relevantEditParts.add((GraphicalEditPart) value);
					}
				}

				// If no dangling BES are found, exit the command
				if (!targetBesFound) {
					return;
				}

				// Sort relevant edit parts by their Y coordinates
				Collections.sort(relevantEditParts, new Comparator<GraphicalEditPart>() {

					@Override
					public int compare(GraphicalEditPart ep1, GraphicalEditPart ep2) {
						int y1 = AdoneSequenceUtil.getAbsoluteBoundsForMessageEp(ep1).y;
						int y2 = AdoneSequenceUtil.getAbsoluteBoundsForMessageEp(ep2).y;
						return Integer.compare(y1, y2);
					}

				});

				// Create BES for dangling views based on their position relative to messages
				for (GraphicalEditPart ep : relevantEditParts) {

					if (ep instanceof BehaviorExecutionSpecificationEditPart) {
						BehaviorExecutionSpecificationEditPart besEp = (BehaviorExecutionSpecificationEditPart) ep;

						if (besEp.resolveSemanticElement() == null) {

							int besEpIndex = relevantEditParts.indexOf(besEp);

							AdoneMessageSyncEditPart targetMessageEp = null;

							// Determine the target message based on position
							if (besEpIndex > 0 && relevantEditParts.get(besEpIndex - 1) instanceof AbstractMessageEditPart) {
								targetMessageEp = (AdoneMessageSyncEditPart) relevantEditParts.get(besEpIndex - 1);
							}

							if (relevantEditParts.get(besEpIndex + 1) instanceof AbstractMessageEditPart) {
								targetMessageEp = (AdoneMessageSyncEditPart) relevantEditParts.get(besEpIndex + 1);
							}

							// Create a new BES in the model if the Y coordinates match
							if (targetMessageEp != null && AdoneSequenceUtil.getAbsoluteBoundsForMessageEp(targetMessageEp).y == AdoneSequenceUtil.getAbsoluteBoundsForMessageEp(besEp).y) {

								Message targetMsg = (Message) targetMessageEp.resolveSemanticElement();

								MessageOccurrenceSpecification mos = (MessageOccurrenceSpecification) targetMsg.getReceiveEvent();
								Namespace owner = (Namespace) mos.eContainer();

								// Create and set the new BES
								BehaviorExecutionSpecification bes = UMLFactory.eINSTANCE.createBehaviorExecutionSpecification();
								if (owner instanceof Interaction) {
									Interaction intac = (Interaction) owner;
									bes.setEnclosingInteraction(intac);
								} else if (owner instanceof InteractionOperand) {
									InteractionOperand operand = (InteractionOperand) owner;
									bes.setEnclosingOperand(operand);
								}

								// Link the new BES to the graphical part's view
								View besEpView = besEp.getNotationView();
								besEpView.setElement(bes);

							}
						}
					}
				}
			}

			@Override
			public void redo() {
				// Redo logic could be implemented if necessary
			}

		});

	}

	/**
	 * Updates the Z-order of graphical components in a Sequence Diagram based on their Y-axis positions.
	 * This command organizes graphical edit parts such as messages, combined fragments, and interaction
	 * operands to ensure that they are layered in a visually coherent manner, reflecting the logical
	 * flow of interactions. By sorting these components according to their vertical (Y) positions, the
	 * diagram maintains a clear and understandable structure, facilitating easier interpretation and
	 * analysis of the sequence of events.
	 */
	private void updateZOrderByGraphicalEditParts() {

		execute(new AbstractCommand("Update Graphical ZOrder") {

			@Override
			public void execute() {

				EditPartViewer viewer = getHost().getRoot().getViewer();
				Map<?, ?> editPartRegistry = viewer.getEditPartRegistry();

				List<GraphicalEditPart> relevantEditParts = new ArrayList<>();
				// Filter and add required types of edit parts to the list
				for (Object value : editPartRegistry.values()) {
					if (value instanceof AbstractMessageEditPart || value instanceof CombinedFragmentEditPart || value instanceof InteractionOperandEditPart || value instanceof InteractionOperandGuardEditPart) {
						relevantEditParts.add((GraphicalEditPart) value);
					}
				}

				// Sort the collected edit parts by their Y coordinates
				Collections.sort(relevantEditParts, new Comparator<GraphicalEditPart>() {

					@Override
					public int compare(GraphicalEditPart ep1, GraphicalEditPart ep2) {
						int y1 = AdoneSequenceUtil.getAbsoluteBoundsForMessageEp(ep1).y;
						int y2 = AdoneSequenceUtil.getAbsoluteBoundsForMessageEp(ep2).y;
						return Integer.compare(y1, y2);
					}

				});

				// Attempt to build or update the Z-order structure based on sorted list
				try {

					buildEditPartZOrderStructure(relevantEditParts);

				} catch (Exception e) {
					e.printStackTrace();
				}

			}

			@Override
			public void redo() {
				// Redo logic could be implemented if necessary
			}

			@Override
			public boolean canUndo() {
				// TODO Auto-generated method stub
				return false;
			}

		});

	}

	/**
	 * Reorganizes the Z-order of edit parts in a Sequence Diagram to maintain a logical and visually
	 * coherent structure, especially for nested Combined Fragments (CFs) and Interaction Operands.
	 * This method ensures that all lifelines are positioned in front of CFs and that nested CFs are
	 * correctly layered in accordance with their nesting structure. It leverages a stack to track
	 * the nesting hierarchy of CFs and Interaction Operands, adjusting their positions in the diagram
	 * to reflect their logical containment and sequence.
	 *
	 * @param sortedEditParts
	 *            A list of GraphicalEditParts sorted by their Y coordinates.
	 */
	private void buildEditPartZOrderStructure(List<GraphicalEditPart> sortedEditParts) {

		/// Stack to track the nested structure of fragments
		Stack<GraphicalEditPart> fragmentStack = new Stack<>();

		// Adjust positions of all lifelines in relation to CFs for Z-ordering
		this.adjustLifelinePositions(sortedEditParts);

		// Adjusts the positions of nested Combined Fragments (CFs) to ensure that
		// they appear in front of their containing CFs in cases of nesting structures.
		for (GraphicalEditPart editPart : sortedEditParts) {

			Rectangle editPartBounds = AdoneSequenceUtil.getAbsoluteBoundsForMessageEp(editPart);

			// Pop the stack until the current editPart is outside the scope of the top stack element
			while (!fragmentStack.isEmpty()) {
				EditPart parentEp = fragmentStack.peek();
				Rectangle parentBound = AdoneSequenceUtil.getAbsoluteBoundsForMessageEp((GraphicalEditPart) parentEp);
				int parentScope = parentBound.y + parentBound.height;
				// 중첩 가능성 때문에 +1 처리
				if (editPartBounds.y + 1 > parentScope) {
					fragmentStack.pop();
				} else {
					break;
				}
			}

			if (editPart instanceof CombinedFragmentEditPart) {

				AdoneCombinedFragmentEditPart cfEp = (AdoneCombinedFragmentEditPart) editPart;

				View cfView = cfEp.getNotationView();
				View containerView = ViewUtil.getContainerView(cfView);

				// Adjust the position of the CF based on its parent in the stack
				if (!fragmentStack.isEmpty()) {
					InteractionOperandEditPart operandEp = (InteractionOperandEditPart) fragmentStack.peek();
					CombinedFragmentEditPart parentCf = (CombinedFragmentEditPart) operandEp.getParent().getParent();
					View parentCfView = parentCf.getNotationView();

					List children = containerView.getChildren();
					int oldIndex = children.indexOf(parentCfView);
					if (oldIndex < children.size() - 1) {
						ViewUtil.repositionChildAt(containerView, cfView, oldIndex + 1);
					}
				}

				// Push the current CF on the stack
				fragmentStack.push(cfEp);

			} else if (editPart instanceof InteractionOperandEditPart) {
				// Interaction Operands are also considered for nesting
				InteractionOperandEditPart ioEditPart = (InteractionOperandEditPart) editPart;
				fragmentStack.push(ioEditPart);
			} else if (editPart instanceof AbstractMessageEditPart) {
				// Messages do not affect the nesting structure directly
				// No action is needed for message edit parts in this context
			}
		}

	}

	/**
	 * Adjusts the positions of all lifeline views to ensure they are placed after the last CombinedFragment (CF)
	 * within the graphical representation of a Sequence Diagram. This method identifies the index of the last CF
	 * and moves all lifeline views to positions immediately following this CF, maintaining the logical and visual
	 * coherence of the diagram's structure. This adjustment is crucial for diagrams with nested CFs, ensuring
	 * lifelines are visually represented in front of these CFs.
	 *
	 * @param sortedEditParts
	 *            A list of GraphicalEditParts sorted by their graphical order, including CFs and lifelines.
	 */
	private void adjustLifelinePositions(List<GraphicalEditPart> sortedEditParts) {

		int latestCfIndex = -1; // Tracks the index of the latest (last) CF in the containerView
		View containerView = null; // Container view for CFs and lifelines

		// Find the index of the last CF in the diagram
		for (GraphicalEditPart part : sortedEditParts) {
			if (part instanceof CombinedFragmentEditPart) {

				CombinedFragmentEditPart cfPart = (CombinedFragmentEditPart) part;

				containerView = ViewUtil.getContainerView(cfPart.getNotationView());

				if (containerView != null) {
					int index = containerView.getChildren().indexOf(cfPart.getNotationView());
					if (index > latestCfIndex) {
						latestCfIndex = index;
					}
				} else {
					// Log or handle the case where the CF's container view is null why ? (2024-01-18)
					System.out.println("CF container view is null : " + cfPart.toString());
				}


			}
		}

		// Move all lifeline views to positions after the last CF
		if (latestCfIndex != -1 && containerView != null) {
			List<View> lifelineViewsToMove = new ArrayList<>();
			for (Object child : containerView.getChildren()) {
				if (child instanceof View) {
					View childView = (View) child;
					if (childView.getElement() instanceof Lifeline) {
						lifelineViewsToMove.add(childView);
					}
				}
			}

			int targetIndex = latestCfIndex + 1;
			for (View lifelineView : lifelineViewsToMove) {
				if (targetIndex < containerView.getChildren().size()) {
					ViewUtil.repositionChildAt(containerView, lifelineView, targetIndex);
				} else {
					// If the target index exceeds the number of children, remove and re-add the view at the end
					containerView.removeChild(lifelineView);
					containerView.insertChild(lifelineView);
				}
			}
		}
	}

	/**
	 * Updates the graphical location of BehaviorExecutionSpecifications (BES) in a Sequence Diagram
	 * to align with their corresponding messages. This command scans all message edit parts, identifies
	 * the BES that follow each message, and adjusts the BES's vertical position to match the message's
	 * start point. This alignment is crucial for accurately representing the start time of behaviors
	 * in sequence diagrams. Special consideration is given to self-messages, where the BES's position
	 * is adjusted to account for the height of the self-message loop, ensuring visual consistency and
	 * correct semantic representation.
	 */
	private void updateBehaviorExeSpecLocation() {

		execute(new AbstractCommand("Update BehaviorExecutionSpec Location") {

			@Override
			public void execute() {

				EditPartViewer viewer = getHost().getRoot().getViewer();
				Map<?, ?> editPartRegistry = viewer.getEditPartRegistry();

				// Iterate through all message edit parts to adjust BES locations
				for (Object value : editPartRegistry.values()) {
					if (value instanceof AbstractMessageEditPart) {

						AbstractMessageEditPart msgEp = (AbstractMessageEditPart) value;
						Message msg = (Message) msgEp.resolveSemanticElement();
						BehaviorExecutionSpecification bes = AdoneSequenceUtil.getFollowingBehaviorExeSpec(msg);
						BehaviorExecutionSpecificationEditPart besEp = (BehaviorExecutionSpecificationEditPart) AdoneSequenceUtil.getEditPartFromSemantic(msgEp, bes);

						if (besEp != null) {

							// Get absolute bounds for message and BES
							Rectangle msgBound = AdoneSequenceUtil.getAbsoluteBoundsForMessageEp(msgEp);

							// Adjust for self-messages's receive position (2024-01-25)
							if (SelfMessageHelper.isSelfLink((AbstractMessageEditPart) value)) {
								msgBound.y = msgBound.y + msgBound.height;
							}

							Rectangle besBound = AdoneSequenceUtil.getAbsoluteBoundsForMessageEp(besEp);

							// Align BES position with message if they differ
							if (msgBound.y != besBound.y) {
								int delta = msgBound.y - besBound.y;
								View view = (View) besEp.getModel();
								Bounds bounds = (Bounds) ((Node) view).getLayoutConstraint();
								bounds.setY(bounds.getY() + delta); // Update Y position
							}

						}

					}
				}
			}

			@Override
			public void redo() {
				// Redo implementation is optional and context-specific
			}

		});

	}

	/**
	 * Corrects the creation of BehaviorExecutionSpecification objects during recursive message generation
	 * in Papyrus. Specifically, this method addresses an issue where the start event of a
	 * BehaviorExecutionSpecification is incorrectly set as an ExecutionOccurrenceSpecification instead of
	 * the required MessageOccurrenceSpecification for self-call messages. It iterates through all
	 * InteractionFragments, identifies BehaviorExecutionSpecifications with this issue, and corrects their
	 * start events to the appropriate MessageOccurrenceSpecification instances. Additionally, it removes
	 * the incorrectly assigned ExecutionOccurrenceSpecifications from the model.
	 */
	private void deleteExecutionOcSpecForSelfCall() {

		execute(new AbstractCommand("Delete ExecutionOcSpec For Self Call") {

			@Override
			public void execute() {
				// Retrieve all interaction fragments from the interaction
				List<InteractionFragment> fragments = AdoneSequenceUtil.getAllInteractionFragments(intac);
				Map<InteractionFragment, String> removeTargetEosRegistry = new HashMap<>();

				InteractionFragment lastReceivedEvent = null;

				for (InteractionFragment frg : fragments) {

					// Process MessageOccurrenceSpecifications to find the last received event
					if (frg instanceof MessageOccurrenceSpecification) {
						MessageOccurrenceSpecification mos = (MessageOccurrenceSpecification) frg;

						if (mos.getMessage() == null) {
							continue;
						}

						if (mos.getMessage().getReceiveEvent() == null) {
							continue;
						}

						if (mos.getMessage().getReceiveEvent().equals(mos)) {
							lastReceivedEvent = mos;
						}

					}

					// Identify and correct BehaviorExecutionSpecifications with incorrect start events
					if (frg instanceof BehaviorExecutionSpecification) {
						BehaviorExecutionSpecification bes = (BehaviorExecutionSpecification) frg;

						if (bes.getStart() == null) {
							continue;
						}

						if (bes.getStart() instanceof ExecutionOccurrenceSpecification) {

							ExecutionOccurrenceSpecification eos = (ExecutionOccurrenceSpecification) bes.getStart();

							if (eos.getName().endsWith("Finish")) {
								continue;
							}

							bes.setStart((OccurrenceSpecification) lastReceivedEvent);
							removeTargetEosRegistry.put(eos, null);// Mark for removal
						}
					}
				}

				// Remove the incorrectly assigned ExecutionOccurrenceSpecifications from the model
				for (InteractionFragment targetIfg : removeTargetEosRegistry.keySet()) {
					EcoreUtil.remove(targetIfg);
				}

			}

			@Override
			public void redo() {
				// Redo logic if applicable
			}

			@Override
			public boolean canUndo() {
				return false; // This operation cannot be undone
			}

		});

	}

	/**
	 * Updates the structure of InteractionFragments in the UML model to match the graphical arrangement
	 * of EditParts in a Sequence Diagram. This command sorts relevant graphical EditParts by their Y-axis
	 * positions and rebuilds the interaction's fragment structure to reflect this order, ensuring the
	 * model's integrity aligns with the visual representation. This process is crucial for maintaining
	 * consistency between the diagram's visual layout and the underlying model, particularly after
	 * graphical rearrangements that do not automatically update the model.
	 */
	private void updateFragmentsByGraphicalEditParts() {

		execute(new AbstractCommand("Build InteractionFragment Structure with Graphycal Editpart Structure") {

			@Override
			public void execute() {

				EditPartViewer viewer = getHost().getRoot().getViewer();
				Map<?, ?> editPartRegistry = viewer.getEditPartRegistry();

				List<GraphicalEditPart> relevantEditParts = new ArrayList<>();
				/// Filter and collect necessary types of EditParts
				for (Object value : editPartRegistry.values()) {
					if (value instanceof AbstractMessageEditPart || value instanceof CombinedFragmentEditPart || value instanceof InteractionOperandEditPart) {
						relevantEditParts.add((GraphicalEditPart) value);
					}
				}

				// Sort the collected EditParts by their Y coordinates
				Collections.sort(relevantEditParts, new Comparator<GraphicalEditPart>() {

					@Override
					public int compare(GraphicalEditPart ep1, GraphicalEditPart ep2) {
						int y1 = AdoneSequenceUtil.getAbsoluteBoundsForMessageEp(ep1).y;
						int y2 = AdoneSequenceUtil.getAbsoluteBoundsForMessageEp(ep2).y;
						return Integer.compare(y1, y2);
					}

				});

				try {

					// Copy the interaction and diagrams for potential rollback
					copyInteraction = EcoreUtil.copy(intac);

					List<Diagram> diagrams = AdoneDiagramUtil.getAllSequenceDiagrams(intac);

					if (!diagrams.isEmpty()) {
						currentDiagram = AdoneDiagramUtil.getAllSequenceDiagrams(intac).get(0);
						copyDiagram = EcoreUtil.copy(AdoneDiagramUtil.getAllSequenceDiagrams(intac).get(0));
					} else {
						currentDiagram = null;
						copyDiagram = null;
					}

					// Rebuild the structure based on the sorted EditParts
					buildEditPartStructure(relevantEditParts);

				} catch (Exception e) {

					// Potential rollback logic if needed

					// intac.getFragments().clear();
					// intac.getFragments().addAll(copyInteraction.getFragments());
					// if (currentDiagram != null && copyDiagram != null) {
					// // EcoreUtil.remove(currentDiagram);
					// currentDiagram = EcoreUtil.copy(copyDiagram);
					// }

					e.printStackTrace();
				}

			}

			@Override
			public void redo() {
				// Redo implementation is optional
			}

			@Override
			public boolean canUndo() {
				return false; // This operation does not support undo functionality
			}

		});

	}


	/**
	 * Reconstructs the structure of InteractionFragments in the UML model based on the sorted graphical
	 * representation of EditParts within a Sequence Diagram. This method ensures that the logical
	 * sequence of interactions, as visually represented by Combined Fragments, Interaction Operands, and
	 * Messages, is accurately reflected in the model. It utilizes a stack to manage the nesting of
	 * Combined Fragments and Interaction Operands, aligning the model's structure with the graphical
	 * arrangement. This alignment is crucial for maintaining the integrity and coherence of the sequence
	 * diagram's underlying model.
	 *
	 * @param sortedEditParts
	 *            A list of GraphicalEditParts sorted by their Y coordinates.
	 */
	private void buildEditPartStructure(List<GraphicalEditPart> sortedEditParts) {

		List<InteractionFragment> reStructuredFragments = this.intac.getFragments();

		// Stack to track the nested structure of Combined Fragments and Interaction Operands
		Stack<GraphicalEditPart> fragmentStack = new Stack<>();

		// Registry to track the order of fragments within Interactions or Operands
		Map<Object, Integer> fragmentOrderRegistry = new HashMap<>();

		// Target Interaction for updating fragments
		Interaction targetInteraction = this.intac;

		// Iterate through sorted EditParts to rebuild the fragment structure
		for (GraphicalEditPart editPart : sortedEditParts) {
			Rectangle editPartBounds = AdoneSequenceUtil.getAbsoluteBoundsForMessageEp(editPart);

			// Remove elements from the stack that are no longer in scope based on the current edit part's position
			while (!fragmentStack.isEmpty()) {
				EditPart parentEp = fragmentStack.peek();
				Rectangle parentBound = AdoneSequenceUtil.getAbsoluteBoundsForMessageEp((GraphicalEditPart) parentEp);
				int parentScope = parentBound.y + parentBound.height;
				// 부모의 종료 지점과 자식의 시작 지점의 중첩 가능성 때문에 +1 처리
				if (editPartBounds.y + 1 > parentScope) {
					fragmentStack.pop();
				} else {
					break;
				}
			}

			// Handle CombinedFragmentEditParts by adding them to the interaction or the correct nested container
			if (editPart instanceof CombinedFragmentEditPart) {

				CombinedFragmentEditPart cfEp = (CombinedFragmentEditPart) editPart;
				CombinedFragment cf = (CombinedFragment) cfEp.resolveSemanticElement();

				// Directly add to interaction if not nested, otherwise add to the nested container
				if (fragmentStack.isEmpty()) {

					// add fragments to interaction

					int currentFragmentIndex = this.getCurrentInteractionFragmentIndex(fragmentOrderRegistry, targetInteraction);
					int insertIndex = this.getFragmentInsertIndex(reStructuredFragments, currentFragmentIndex);

					this.removeFragmentFromContainer(cf);
					reStructuredFragments.add(insertIndex, cf);

				} else {

					// add fragments to interactionOperand

					if (fragmentStack.peek() instanceof InteractionOperandEditPart) {
						InteractionOperandEditPart IoEditPart = (InteractionOperandEditPart) fragmentStack.peek();
						InteractionOperand parentOperand = (InteractionOperand) IoEditPart.resolveSemanticElement();

						int currentFragmentIndex = this.getCurrentOperandFragmentIndex(fragmentOrderRegistry, parentOperand);
						int insertIndex = this.getFragmentInsertIndex(parentOperand.getFragments(), currentFragmentIndex);

						this.removeFragmentFromContainer(cf);
						parentOperand.getFragments().add(insertIndex, cf);

					}
				}

				fragmentStack.push(cfEp);

				// Handle InteractionOperandEditParts by adding them to their parent CombinedFragment
			} else if (editPart instanceof InteractionOperandEditPart) {

				InteractionOperandEditPart ioEditPart = (InteractionOperandEditPart) editPart;
				InteractionOperand operand = (InteractionOperand) ioEditPart.resolveSemanticElement();
				if (!fragmentStack.isEmpty() && fragmentStack.peek() instanceof CombinedFragmentEditPart) {
					CombinedFragmentEditPart parentCfEp = (CombinedFragmentEditPart) fragmentStack.peek();
					CombinedFragment parentCf = (CombinedFragment) parentCfEp.resolveSemanticElement();

					// add current InteractionOperand to parent CombinedFragment

					if (!operand.eContainer().equals(parentCf)) {
						this.removeFragmentFromContainer(operand);
						parentCf.getOperands().add(operand);
					}
				}

				fragmentStack.push(ioEditPart);

				// Handle AbstractMessageEditParts by adding associated Message and BehaviorExecutionSpecification to the correct container
			} else if (editPart instanceof AbstractMessageEditPart) {
				AbstractMessageEditPart msgEp = (AbstractMessageEditPart) editPart;
				Message msg = (Message) msgEp.resolveSemanticElement();
				BehaviorExecutionSpecification bes = AdoneSequenceUtil.getFollowingBehaviorExeSpec(msg);

				// Extract start and finish events for the message and BES
				MessageOccurrenceSpecification sendMos = (MessageOccurrenceSpecification) msg.getSendEvent();
				MessageOccurrenceSpecification receiveMos = (MessageOccurrenceSpecification) msg.getReceiveEvent();

				ExecutionOccurrenceSpecification finishBes = null;
				// OccurrenceSpecification finishBes = null;
				if (bes != null) {
					// java.lang.ClassCastException: class org.eclipse.uml2.uml.internal.impl.MessageOccurrenceSpecificationImpl cannot be cast to class org.eclipse.uml2.uml.ExecutionOccurrenceSpecification
					// (org.eclipse.uml2.uml.internal.impl.MessageOccurrenceSpecificationImpl and org.eclipse.uml2.uml.ExecutionOccurrenceSpecification are in unnamed module of loader org.eclipse.osgi.internal.loader.EquinoxClassLoader @30dd0f78)

					// Add message events and BES to the interaction or the nested container based on the current stack
					if (bes.getFinish() instanceof MessageOccurrenceSpecification) {

						for (InteractionFragment ifg : intac.getFragments()) {
							if (ifg instanceof ExecutionOccurrenceSpecification) {
								ExecutionOccurrenceSpecification eos = (ExecutionOccurrenceSpecification) ifg;
								if ((eos.getName()).equals(bes.getName() + "Finish")) {
									finishBes = eos;
									bes.setFinish(eos);
									break;
								}
							}
						}

					} else if (bes.getFinish() instanceof ExecutionOccurrenceSpecification) {
						finishBes = (ExecutionOccurrenceSpecification) bes.getFinish();
					}

				} else {
					System.out.println("BES is null : " + msgEp.toString());
				}

				if (fragmentStack.isEmpty()) {

					// add fragments to interaction
					int currentFragmentIndex = this.getCurrentInteractionFragmentIndex(fragmentOrderRegistry, targetInteraction);
					int insertIndex = this.getFragmentInsertIndex(reStructuredFragments, currentFragmentIndex);

					this.removeFragmentFromContainer(sendMos);
					reStructuredFragments.add(insertIndex, sendMos);

					this.removeFragmentFromContainer(receiveMos);
					reStructuredFragments.add(insertIndex + 1, receiveMos);

					if (bes != null) {
						this.removeFragmentFromContainer(bes);
						reStructuredFragments.add(insertIndex + 2, bes);

						if (finishBes != null) {
							this.removeFragmentFromContainer(finishBes);
							reStructuredFragments.add(insertIndex + 3, finishBes);
						}
					}

				} else {

					// add fragments to interactionOperand
					if (fragmentStack.peek() instanceof InteractionOperandEditPart) {
						InteractionOperandEditPart IoEditPart = (InteractionOperandEditPart) fragmentStack.peek();
						InteractionOperand parentOperand = (InteractionOperand) IoEditPart.resolveSemanticElement();

						int currentFragmentIndex = this.getCurrentOperandFragmentIndex(fragmentOrderRegistry, parentOperand);
						int insertIndex = this.getFragmentInsertIndex(parentOperand.getFragments(), currentFragmentIndex);

						this.removeFragmentFromContainer(sendMos);
						parentOperand.getFragments().add(insertIndex, sendMos);

						this.removeFragmentFromContainer(receiveMos);
						parentOperand.getFragments().add(insertIndex + 1, receiveMos);


						if (bes != null) {
							this.removeFragmentFromContainer(bes);
							parentOperand.getFragments().add(insertIndex + 2, bes);

							this.removeFragmentFromContainer(finishBes);
							parentOperand.getFragments().add(insertIndex + 3, finishBes);
						}

					}
				}
			}
		}

	}

	/**
	 * Determines and updates the current index for the next fragment to be added to a specified InteractionOperand.
	 * Utilizes a registry map to keep track of and increment the last index used for fragments within a particular
	 * InteractionOperand. This systematic tracking is essential for preserving the order of fragments as they are
	 * added or adjusted within an InteractionOperand, crucial for the coherent representation of nested interactions
	 * or alternative flows within a Sequence Diagram.
	 *
	 * @param fragmentOrderRegistry
	 *            A map that records the last index used for fragments within each InteractionOperand.
	 * @param parentOperand
	 *            The InteractionOperand for which the fragment index is being calculated.
	 * @return The next index to be used for adding a fragment to the specified InteractionOperand.
	 */
	private int getCurrentOperandFragmentIndex(Map<Object, Integer> fragmentOrderRegistry, InteractionOperand parentOperand) {

		int currentFragmentIndex = 0;

		// If the parentOperand does not yet have an entry in the registry, initialize it
		if (fragmentOrderRegistry.get(parentOperand) == null) {
			// Starting the indexing from 1 for this parentOperand
			currentFragmentIndex = 1;
			fragmentOrderRegistry.put(parentOperand, Integer.valueOf(1));
		} else {
			// If it already exists, increment the last index used
			int lastFragmentIndex = fragmentOrderRegistry.get(parentOperand);
			currentFragmentIndex = lastFragmentIndex + 1;
			fragmentOrderRegistry.put(parentOperand, currentFragmentIndex);
		}

		return currentFragmentIndex;
	}

	/**
	 * Calculates and updates the current index for the next InteractionFragment to be added to the target
	 * Interaction. This method uses a registry map to track and increment the last used index for fragments
	 * within a specific Interaction, ensuring that each new fragment is assigned a unique sequential index.
	 * This index helps in maintaining the order of fragments as they are manipulated or added to the
	 * Interaction, which is crucial for accurately reflecting the sequence of events in a Sequence Diagram.
	 *
	 * @param fragmentOrderRegistry
	 *            A map that keeps track of the last index used for fragments within each Interaction.
	 * @param targetInteraction
	 *            The Interaction to which the fragment index is being calculated.
	 * @return The next index to be used for a fragment within the specified Interaction.
	 */
	private int getCurrentInteractionFragmentIndex(Map<Object, Integer> fragmentOrderRegistry, Interaction targetInteraction) {

		int currentFragmentIndex = 0;

		// Check if the target Interaction is already in the registry map
		if (fragmentOrderRegistry.get(targetInteraction) == null) {
			// If not, start indexing for this Interaction from 1
			currentFragmentIndex = 1;
			fragmentOrderRegistry.put(targetInteraction, Integer.valueOf(1));
		} else {
			// If yes, increment the last index used for this Interaction
			int lastFragmentIndex = fragmentOrderRegistry.get(targetInteraction);
			currentFragmentIndex = lastFragmentIndex + 1;
			fragmentOrderRegistry.put(targetInteraction, currentFragmentIndex);
		}

		return currentFragmentIndex;
	}

	/**
	 * Calculates the index within the list of InteractionFragments where a new fragment should be inserted,
	 * based on a target index that represents the desired sequential position among specific types of fragments
	 * (MessageOccurrenceSpecifications and CombinedFragments). This method ensures that new fragments are
	 * inserted at the correct position to maintain the logical flow of interactions within a Sequence Diagram.
	 * Special attention is given to MessageOccurrenceSpecifications, where only the send events are counted
	 * towards the target index, reflecting their role in defining the sequence of interactions.
	 *
	 * @param fragments
	 *            The list of existing InteractionFragments within an Interaction or InteractionOperand.
	 * @param targetFragmentIndex
	 *            The target sequential index among MessageOccurrenceSpecifications (send events only) and CombinedFragments.
	 * @return The actual index in the list where the new fragment should be inserted.
	 */
	private int getFragmentInsertIndex(List<InteractionFragment> fragments, int targetFragmentIndex) {

		// The calculated index in the list where the new fragment should be inserted
		int moveTargetFragmentIndex = 0;

		// Counter for MessageOccurrenceSpecifications (send events) and CombinedFragments
		int messageCombinedFragmentIndex = 0;

		for (InteractionFragment fragment : fragments) {
			if (fragment instanceof MessageOccurrenceSpecification) {
				MessageOccurrenceSpecification mos = (MessageOccurrenceSpecification) fragment;

				if (mos.getMessage() == null) {
					// Skip this fragment due to missing message reference, requiring further investigation (2024-01-15)
					continue;
				}

				// Count only the send events of messages towards the target index
				if (mos.getMessage().getSendEvent().equals(mos)) {
					messageCombinedFragmentIndex++;
				}

			} else if (fragment instanceof CombinedFragment) {
				// CombinedFragments are also counted towards the target index
				messageCombinedFragmentIndex++;
			}

			// When the count matches the target index, determine the insertion point in the list
			if (messageCombinedFragmentIndex == targetFragmentIndex) {
				moveTargetFragmentIndex = fragments.indexOf(fragment);
				break;
			}
		}

		return moveTargetFragmentIndex;
	}

	/**
	 * Removes the specified InteractionFragment from its container, whether that container is
	 * an Interaction or an InteractionOperand. This method ensures that the fragment is properly
	 * detached from its current container in the UML model, facilitating its reassignment to a new
	 * container or its deletion. This operation is critical for maintaining the integrity of the
	 * model when updating the structure of interactions and their fragments. However, when executing
	 * a delete command, undoing this action may lead to issues if the parent's location has changed,
	 * resulting in potential inconsistencies. Continuous monitoring and exploration of solutions
	 * for this issue are necessary to ensure model integrity remains intact during undo operations.
	 *
	 * @param fragment
	 *            The InteractionFragment to be removed from its container.
	 */
	private void removeFragmentFromContainer(InteractionFragment fragment) {

		if (fragment.eContainer() != null) {
			EObject container = fragment.eContainer();
			if (container instanceof Interaction) {
				Interaction intac = (Interaction) fragment.eContainer();
				intac.getFragments().remove(fragment);
			} else if (container instanceof InteractionOperand) {
				InteractionOperand operand = (InteractionOperand) fragment.eContainer();
				operand.getFragments().remove(fragment);
			} else {
				// Log an error or take appropriate action if the fragment's container is not recognized
				System.out.println("Fragment container is not recognized: " + fragment.toString());
			}
		}
	}

	/**
	 * Removes dangling BehaviorExecutionSpecifications (BES) from the UML model of a Sequence Diagram.
	 * Dangling BES are identified as those with a start point that does not correspond to an actual
	 * message (MessageOccurrenceSpecification without a message). This method ensures the integrity
	 * of the sequence diagram by eliminating these orphaned specifications, which do not contribute
	 * to the diagram's logical flow and might result from incomplete or erroneous editing actions.
	 */
	private void deleteDangglingBes() {

		execute(new AbstractCommand() {

			@Override
			public void execute() {

				// Collect BES that should be removed because they start with an MOS without a message
				Map<BehaviorExecutionSpecification, String> removeTargetBes = new HashMap<>();
				for (InteractionFragment ifg : AdoneSequenceUtil.getAllInteractionFragments(intac)) {
					if (ifg instanceof BehaviorExecutionSpecification) {
						BehaviorExecutionSpecification bes = (BehaviorExecutionSpecification) ifg;
						if (bes.getStart() != null) {
							MessageOccurrenceSpecification mos = (MessageOccurrenceSpecification) bes.getStart();
							if (mos.getMessage() == null) {
								removeTargetBes.put(bes, null);// Mark for removal
							}
						}
					}
				}

				// Remove the identified BES and their start/finish points from the model
				for (BehaviorExecutionSpecification bes : removeTargetBes.keySet()) {
					EcoreUtil.remove(bes.getStart());
					if (bes.getFinish() != null) {
						EcoreUtil.remove(bes.getFinish());
					}
					EcoreUtil.remove(bes);
				}

			}

			@Override
			public void redo() {
				// Redo logic can be implemented if necessary
			}

		});

	}

	/**
	 * Adjusts the end point of the main logic's BehaviorExecutionSpecification (the second lifeline
	 * in the diagram) to the latest possible position in a Sequence Diagram. This method is designed
	 * to compensate for functionality errors in Papyrus by ensuring that the main logic's execution
	 * span covers the entire diagram, enhancing the accuracy of sequence depiction. It identifies
	 * the BehaviorExecutionSpecification's finish point, whether an ExecutionOccurrenceSpecification
	 * or a MessageOccurrenceSpecification, and relocates it to the end of the interaction fragments
	 * list if not already the last element, ensuring the main logic visually extends to the end of the
	 * sequence.
	 */
	private void updateMainLogicBesFinishFragment() {

		execute(new AbstractCommand() {

			@Override
			public void execute() {
				ExecutionOccurrenceSpecification finishExecutionOccurence = null;
				MessageOccurrenceSpecification finishMessageOccurence = null;
				BehaviorExecutionSpecification firstBes = null;

				// Iterate through interaction fragments to find the first BES and its finish point
				for (InteractionFragment ifg : intac.getFragments()) {
					if (ifg instanceof BehaviorExecutionSpecification) {
						firstBes = (BehaviorExecutionSpecification) ifg;
						if (firstBes.getFinish() instanceof ExecutionOccurrenceSpecification) {
							finishExecutionOccurence = (ExecutionOccurrenceSpecification) firstBes.getFinish();
						} else if (firstBes.getFinish() instanceof MessageOccurrenceSpecification) {
							finishMessageOccurence = (MessageOccurrenceSpecification) firstBes.getFinish();
						}
						break;// Stop after finding the first BES
					}
				}

				// Attempt to locate a matching ExecutionOccurrenceSpecification if not directly associated with BES
				if (finishExecutionOccurence == null) {
					for (InteractionFragment ifg : intac.getFragments()) {
						if (ifg instanceof ExecutionOccurrenceSpecification) {
							ExecutionOccurrenceSpecification eos = (ExecutionOccurrenceSpecification) ifg;
							if ((eos.getName()).equals(firstBes.getName() + "Finish")) {
								finishExecutionOccurence = eos;
								firstBes.setFinish(eos); // Update BES finish point
								break;
							}
						}
					}
				}

				List<InteractionFragment> fragments = intac.getFragments();

				// Only adjust position if the finish point exists and is not already the last element
				if (fragments.contains(finishExecutionOccurence) &&
						!fragments.get(fragments.size() - 1).equals(finishExecutionOccurence)) {

					// Remove from its current position
					fragments.remove(finishExecutionOccurence);

					// Add to the end of the list
					fragments.add(finishExecutionOccurence);
				}

			}

			@Override
			public void redo() {
				// Redo implementation is not required for the purpose of this command
			}

		});



	}

	/**
	 * Retrieves the Interaction instance associated with the host EditPart. If the interaction has not
	 * been previously cached, it fetches the Interaction from the model associated with the host EditPart
	 * and caches it for future use. This method ensures efficient access to the Interaction instance by
	 * avoiding repeated fetches from the model.
	 *
	 * @return Interaction The Interaction instance associated with the host EditPart.
	 */
	private Interaction getInteraction() {
		if (intac == null) {
			// Lazily initializes 'intac' by fetching the Interaction from the host's model if not already done
			intac = (Interaction) ((View) getHost().getModel()).getElement();
		}
		return intac; // Returns the cached Interaction instance
	}


	/**
	 * Responds to changes in the model by scheduling updates to the graphical representation of the
	 * sequence diagram. Initially updates covered elements and their owners. To address graphical
	 * inconsistencies and ensure the UI reflects the current model state, it further schedules
	 * updates at subsequent intervals. This method leverages the Eclipse UI thread to ensure updates
	 * are executed safely in a graphical environment. It aims to rectify visual issues arising from
	 * immediate model changes and the specific need to correct the positioning of recursive messages.
	 *
	 * @param notification
	 *            The notification of the change event triggering this update process.
	 */
	@Override
	public void notifyChanged(Notification notification) {

		// Initial update to handle immediate changes in covered elements and owners
		this.updateCoveredAndOwnerAfterUpdate();

		// Schedule a graphical update 2 seconds after the change. This delay allows for the model
		// and initial UI updates to stabilize before attempting to refresh the graphical view.
		Display.getDefault().asyncExec(() -> {
			scheduler.schedule(() -> {
				Display.getDefault().asyncExec(() -> {
					// Reinvoke the update method to ensure graphical consistency
					this.updateCoveredAndOwnerAfterUpdate();
				});
			}, 2, TimeUnit.SECONDS); // Delay set to 2 seconds for the first scheduled update
		});

		// Additional scheduled update 5 seconds later to address any lingering graphical issues
		// that may not have been resolved by the first update.
		Display.getDefault().asyncExec(() -> {
			scheduler.schedule(() -> {
				Display.getDefault().asyncExec(() -> {
					// Another invocation of the update method for thorough consistency
					this.updateCoveredAndOwnerAfterUpdate();
				});
			}, 5, TimeUnit.SECONDS); // Delay set to 5 seconds for the second scheduled update
		});

		// Specifically target the adjustment of recursive message positions with a final update
		// 10 seconds after the initial change. This ensures all prior updates have been processed.
		Display.getDefault().asyncExec(() -> {
			scheduler.schedule(() -> {
				Display.getDefault().asyncExec(() -> {
					// Directly addresses the positioning of behavior execution specifications
					this.updateBehaviorExeSpecLocation();
				});
			}, 10, TimeUnit.SECONDS); // Delay set to 10 seconds for the recursive message adjustment
		});

		// Call to superclass to handle any additional generic notification responses
		super.notifyChanged(notification);

	}

	/**
	 * Deactivates the current component, ensuring any associated scheduler is properly shut down.
	 * This method is critical for releasing resources and preventing memory leaks or lingering
	 * processes after the component is no longer active. By shutting down the scheduler, it
	 * ensures that no pending or future tasks are executed once the component is deactivated,
	 * maintaining system stability and performance.
	 */
	@Override
	public void deactivate() {
		// Check if the scheduler exists and is still running
		if (scheduler != null && !scheduler.isShutdown()) {
			scheduler.shutdown(); // Terminate the scheduler to stop all scheduled tasks
		}
		super.deactivate(); // Proceed with the standard deactivation process
	}


}
